---
title: "Hierarchical Clustering"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hier_clust}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tidyclust)
library(tidyverse)
library(tidymodels)
set.seed(838383)

data("penguins", package = "modeldata")
```


## Setup

**Important:** Make sure to install the developer version of `parsnip` and
`workflows` to access all current functionality of `tidyclust`:

```{r, eval = FALSE}
remotes::install_github("tidymodels/parsnip")
remotes::install_github("tidymodels/workflows@celery")
```

```{r}
library(workflows)
library(parsnip)
```

Load libraries:

```{r setup}
library(tidyclust)
library(tidyverse)
library(tidymodels)
```

```{r setup_secret, echo = FALSE}
library(ggforce)
set.seed(838383)
```

Load and clean a dataset:

```{r}
data("penguins", package = "modeldata")

penguins <- penguins %>%
  select(bill_length_mm, bill_depth_mm) %>%
  drop_na()
```

At the end of this vignette, you will find a brief overview of the hierarchical
clustering
algorithm, as well as some further algorithmic variant details, for those who
would like a reference.

If you have not yet read the `k_means` vignette, we recommend reading that first;
functions that are used in this vignette are explained in more detail there.

## `hier_clust` specification in {tidyclust}

To specify a hierarchical clustering model in `tidyclust`, 
simply choose a value of `num_clusters` and a linkage method:

```{r}
hc_spec <- hier_clust(num_clusters = 3,
                       linkage_method = "average") 

hc_spec
```

There are currently two engines: `stats::kmeans` (default) and 
`ClusterR::KMeans_rcpp`.

It is also possible to change the algorithmic details of the implementation, by
changing the engine and/or using the corresponding arguments from the engine 
functions:

```{r}
kmeans_spec_lloyd <- k_means(num_clusters = 3) %>%
  parsnip::set_engine("stats", algorithm = "Lloyd")

kmeans_spec_cr <- k_means(num_clusters = 3) %>%
  parsnip::set_engine("ClusterR", initializer = "random")
```

Note that the `stats::kmeans` and the `ClusterR::KMeans_rcpp` implementations have
very different default settings for the algorithmic details, so it is recommended
to be deliberate and explicit in choosing these options. (See the end of this
document for detail on the algorithmic options and defaults.)

## Fitting k-means models

Once specified, a model may be "fit" to a dataset by providing a formula and 
data frame in the same manner as a `tidymodels` model fit.  
Note that unlike in supervised modeling, the formula should not include a 
response variable.

```{r}
kmeans_fit <- kmeans_spec %>%
  fit(~ bill_length_mm + bill_depth_mm, 
      data = penguins)

kmeans_fit %>% 
  summary()
```

To access the only the results produced by the engine - in this case, 
`stats::kmeans` - simply extract the fit from the fitted model object:

```{r}
kmeans_fit$fit
```

## A brief introduction to hierarchical clustering

*Hierarchical Clustering*, sometimes called *Agglomerative Clustering*, is a 
method of *unsupervised* learning that produces a *dendrogram*, which can be used
to partition observations into clusters.  

The hierarchical clustering process begins with each observation in it's own
cluster; i.e., *n* clusters for *n* observations.

```{r, echo = FALSE}
fake_dat <- tibble(
  x = sort(runif(5)),
  y = runif(5),
  lab = letters[1:5]
)

fake_dat %>%
  ggplot(aes(x,y)) +
  geom_point(shape = fake_dat$lab, size = 4) +
  geom_point(shape = 1, size = 7, stroke = 1, color = "dark grey") +
  theme_minimal() +
  ylim(c(-0.1, 1.1)) +
  xlim(c(-0.1, 1.1))
```

The closest two observations are then joined together into a single cluster.


```{r, echo = FALSE}
fake_dat_2 <- bind_rows(
  fake_dat[-c(1:2),],
  summarize_all(fake_dat[1:2,], mean)
) %>%
  mutate(
    size = c(rep(1, 3), dist(fake_dat)[1])
  )


fake_dat %>%
  ggplot(aes(x,y)) +
  geom_point(shape = fake_dat$lab, size = 4) +
  geom_point(data = fake_dat_2,
             aes(x=x, y=y), 
             shape = 1, size = 7/fake_dat_2$size, stroke = 1, color = "dark grey") +
  theme_minimal() +
  theme(legend.position = "none") +
  ylim(c(-0.1, 1.1)) +
  xlim(c(-0.1, 1.1))
```

This process continues, with the closest two clusters being joined (or 
"aggolermated") at each step.


```{r, echo = FALSE}
fake_dat_3 <- bind_rows(
  fake_dat[-c(1:3),],
  summarize_all(fake_dat[1:3,], mean)
) %>%
  mutate(
    size = c(rep(1, 2), 0.09)
  )


p1 <- fake_dat %>%
  ggplot(aes(x,y)) +
  geom_point(shape = fake_dat$lab, size = 4) +
  geom_point(data = fake_dat_3,
             aes(x=x, y=y), 
             shape = 1, size = 7/fake_dat_3$size, stroke = 1, color = "dark grey") +
  theme_minimal() +
  theme(legend.position = "none") +
  ylim(c(-0.1, 1.1)) +
  xlim(c(-0.1, 1.1))


fake_dat_4 <- bind_rows(
  summarize_all(fake_dat[1:3,], mean),
  summarize_all(fake_dat[4:5,], mean),
) %>%
  mutate(
    size = c(0.09, 0.09)
  )


p2 <- fake_dat %>%
  ggplot(aes(x,y)) +
  geom_point(shape = fake_dat$lab, size = 4) +
  geom_point(data = fake_dat_4,
             aes(x=x, y=y), 
             shape = 1, size = 7/fake_dat_4$size, stroke = 1, color = "dark grey") +
  theme_minimal() +
  theme(legend.position = "none") +
  ylim(c(-0.1, 1.1)) +
  xlim(c(-0.1, 1.1))

library(patchwork)
p1 + p2
```


The result of the process is a **dendrogram**, which shows the joining of clusters
in tree form:

```{r, echo = FALSE}
hc <- hclust(dist(fake_dat))

plot(hc, labels = fake_dat$lab)
```

### Clusters from dendrogram

To produce a partition-style cluster assignment from the dendrogram, one must
"cut" the tree at a chosen height:

```{r, echo = FALSE}
plot(hc, labels = fake_dat$lab)
abline(h = 0.6, lty = 2, col = "dark grey")
```

The observations that remain joined in the dendrogram below the cut height are
considered to be in a cluster together:

```{r, echo = FALSE}
tibble(
  observation = fake_dat$lab,
  cluster_assignment = cutree(hc, h = 0.6)
)
```


### Methods of aggolmeration

At the every step of the agglomeration, we measure distances between current
clusters.  With each cluster containing (possibly) multiple points, what does
it mean to measure distance?

There are four common approaches to cluster-cluster distancing, aka "linkage":

1. **single linkage:** The distance between two clusters is the distance between
the two **closest** observations.

2. **average linkage:** The distance between two clusters is the average of all
distances between observations in one cluster and observations in the other.

3. **complete linkage:** The distance between two clusters is the distance between
the two **furthest** observations.

4. **centroid method:** The distance between two clusters is the distance between
their centroids (geometric mean or median).

5. **Ward's method:** The distance between two clusters is proportional to the 
increase in **error sum of squares (ESS)** that would result from joining them.
The ESS is computed as the sum of squared distances between observations in a
cluster, and the centroid of the cluster.


It is also worth mentioning the **McQuitty method**, which retains information
about previously joined clusters to measure future linkage distance.  This 
method is currently supported for model fitting, but not for prediction, in
`tidyclust`.
